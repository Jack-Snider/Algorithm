DFS는 Depth-First Search, 깊이 우선 탐색이라고도 부르며, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다.
DFS를 설명하기 전에 먼저 그래프의 기분 구조를 알아야한다.
그래프는 노드와 간선으로 표현되며 이때 노드를 정점이라고도 말한다. 그래프 탐색이란 하나의 노드를 시작으로 다수의 노드를 
방문하는 것을 말한다. 또한 두 노드가 간선으로 연결되어 있다면 '두 노드는 인접하다'라고 표현한다.

여기에서 갑자기 노드와 간선이라는 생소한 단어가 나와서 헷갈릴 수 도 있는데,
일반적으로 그래프를 표현할 때 사용하는 단어들이다. 노드를 도시, 간선을 도로라고 생각해보자.
A라는 도시( 노드 )에서 B라는 도시( 노드 )로 이동하기 위해서 A와 B를 연결하는 도로( 간선 )을 거친다고 이해하면 쉬울 것이다.

프로그래밍에서 그래프는 크게 2가지 방식으로 표현할 수 있는데 코딩 테스트에서는 이 두 방식 모두 필요하니
두 개념에 대해 바르게 알고 있도록 하자.

● 인접행렬( Adjacency Matrix ) : 2차원 배열로 그래프의 연결 관계를 표현하는 방식
● 인접 리스트( Adjacency List) : 리스트로 그래프의 연결 관계를 표현하는 방식

먼저 인접 행렬 방식은 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식이다. 
연결이 되어 있지 않은 노드끼리는 무한의 비용이라고 작성한다. 실제 코드에서는 논리적으로 정답이 
될 수 없는 큰 값 중에서 999999999, 987654321 등의 값으로 초기화하는 경우가 많다.
이렇게 그래프를 인접 행렬 방식으로 처리할 때는 다음과 같이 데이터를 초기화한다.

INF = 999999999 # 무한의 비용 선언

# 2차원 리스트를 이용해 인접 행렬 표현
graph = [
    [ 0,7,5 ],
    [ 7,0, INF ],
    [ 5, INF, 0 ]
]

print( graph )

→ [ [ 0,7,5 ],[ 7,0,999999999 ],[ 5,999999999,0 ] ]

그렇다면 인접 리스트 방식에서는 데이터를 어떤 방식으로 저장할까? 인접 리스트 방식에서는 모든 노드에 연결된 노드에 대한
정보를 차례대로 연결하여 저장한다.

# 행( Row )이 3개인 2차원 리스트로 인접 리스트 표현
graph = [ [] for _ in range( 3 ) ]


# 노드 0에 연결된 노드 정보 저장( 노드, 거리 )
graph[ 0 ].append( ( 1,7 ) )
graph[ 0 ].append( ( 2,5 ) )

# 노드 1에 연결된 노드 정보 저장( 노드, 거리 )
graph[ 1 ].append( ( 0,7 ) )

# 노드 2에 연결된 노드 정보 저장( 노드, 거리 )
graph[ 2 ].append( ( 0,5 ) )

print( graph )

→ [ [ ( 1,7 ), ( 2,5 ) ], [ ( 0,7 ) ], [ ( 0,5 ) ] ]